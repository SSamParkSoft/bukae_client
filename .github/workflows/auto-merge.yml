name: CI/CD

on:
  pull_request:
    types: [opened, synchronize, labeled]
  issue_comment:
    types: [created]
  check_run:
    types: [completed]

jobs:
  check-and-merge:
    runs-on: ubuntu-latest
    # ê° ì´ë²¤íŠ¸ íƒ€ì…ì— ë”°ë¼ PRì´ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
    # pull_request ì´ë²¤íŠ¸: github.event.pull_request ì¡´ì¬
    # issue_comment ì´ë²¤íŠ¸: github.event.issue.pull_request ì¡´ì¬ (PRì¸ ê²½ìš°)
    # check_run ì´ë²¤íŠ¸: github.event.check_run.pull_requests ë°°ì—´ì´ ì¡´ì¬í•˜ê³  ë¹„ì–´ìˆì§€ ì•ŠìŒ
    # ì°¸ê³ : ì‹¤ì œ PR ê²€ì¦(base.ref, state)ì€ ì²« ë²ˆì§¸ stepì—ì„œ ìˆ˜í–‰ë¨
    # ì°¸ê³ : GitHub Actions í‘œí˜„ì‹ì—ì„œëŠ” ë°°ì—´ ê¸¸ì´ë¥¼ ì§ì ‘ í™•ì¸í•  ìˆ˜ ì—†ìœ¼ë¯€ë¡œ,
    #       check_runì˜ ê²½ìš° pull_requests ë°°ì—´ ì¡´ì¬ë§Œ í™•ì¸í•˜ê³ , ì²« ë²ˆì§¸ stepì—ì„œ ë¹ˆ ë°°ì—´ ì²´í¬ ìˆ˜í–‰
    if: |
      (github.event_name == 'pull_request' && github.event.pull_request != null) ||
      (github.event_name == 'issue_comment' && github.event.issue != null && github.event.issue.pull_request != null) ||
      (github.event_name == 'check_run' && github.event.check_run != null && github.event.check_run.pull_requests != null)
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Get PR information and validate
        id: validate_pr
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            let prNumber = null;
            let pr = null;

            // ì´ë²¤íŠ¸ íƒ€ì…ì— ë”°ë¼ PR ë²ˆí˜¸ ê°€ì ¸ì˜¤ê¸°
            if (context.eventName === 'pull_request') {
              prNumber = context.payload.pull_request?.number;
              pr = context.payload.pull_request;
            } else if (context.eventName === 'issue_comment') {
              prNumber = context.payload.issue?.number;
              // issueê°€ PRì¸ì§€ í™•ì¸í•˜ê³  PR ì •ë³´ ê°€ì ¸ì˜¤ê¸°
              if (context.payload.issue?.pull_request) {
                const { data: prData } = await github.rest.pulls.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber,
                });
                pr = prData;
              }
            } else if (context.eventName === 'check_run') {
              // check_runì˜ ê²½ìš° ì²« ë²ˆì§¸ PR ì‚¬ìš©
              const pullRequests = context.payload.check_run?.pull_requests || [];
              if (pullRequests.length > 0) {
                prNumber = pullRequests[0].number;
                const { data: prData } = await github.rest.pulls.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber,
                });
                pr = prData;
              }
            }

            if (!prNumber || !pr) {
              console.log('No PR found or PR is not accessible');
              core.setOutput('is_valid', 'false');
              return;
            }

            // develop ë˜ëŠ” main ë¸Œëœì¹˜ë¡œì˜ PRì¸ì§€ í™•ì¸
            const baseRef = pr.base?.ref;
            const isValidBase = baseRef === 'develop' || baseRef === 'main';
            
            // PRì´ ì—´ë ¤ìˆëŠ”ì§€ í™•ì¸
            const isOpen = pr.state === 'open' && !pr.merged;

            const isValid = isValidBase && isOpen;

            console.log(`PR #${prNumber}: base=${baseRef}, state=${pr.state}, merged=${pr.merged}, isValid=${isValid}`);

            core.setOutput('is_valid', isValid.toString());
            core.setOutput('pr_number', prNumber.toString());
            core.setOutput('pr_sha', pr.head?.sha || context.sha);

            if (!isValid) {
              if (!isValidBase) {
                console.log(`Skipping: PR targets ${baseRef}, not develop or main`);
              } else if (!isOpen) {
                console.log(`Skipping: PR is ${pr.state}${pr.merged ? ' and merged' : ''}`);
              }
            }

      - name: Check if CodeRabbit review is completed
        if: steps.validate_pr.outputs.is_valid == 'true'
        id: check_coderabbit_status
        continue-on-error: true
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = '${{ steps.validate_pr.outputs.pr_number }}';
            const prSha = '${{ steps.validate_pr.outputs.pr_sha }}';
            
            // í•­ìƒ ê¸°ë³¸ê°’ ì„¤ì • (ìŠ¤í…ì´ ì‹¤íŒ¨í•´ë„ ì¶œë ¥ê°’ì´ ì„¤ì •ë˜ë„ë¡)
            let isCompleted = false;
            
            try {
              if (!prNumber) {
                console.log('No PR number found');
                core.setOutput('is_completed', 'false');
                core.setOutput('has_error', 'true');
                return;
              }

              console.log(`Checking CodeRabbit status for PR #${prNumber}...`);

              // CodeRabbit ì²´í¬ ìƒíƒœ í™•ì¸
              const { data: checks } = await github.rest.checks.listForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: prSha,
              });

              const codeRabbitCheck = checks.check_runs.find(
                check => check.name.includes('CodeRabbit') || check.name.includes('code-rabbit')
              );

              if (!codeRabbitCheck) {
                console.log('CodeRabbit check not found - may not have started yet');
                core.setOutput('is_completed', 'false');
                core.setOutput('has_error', 'false');
                return;
              }

              isCompleted = codeRabbitCheck.status === 'completed';
              console.log(`CodeRabbit check status: ${codeRabbitCheck.status}, completed: ${isCompleted}`);
              
              core.setOutput('is_completed', isCompleted.toString());
              core.setOutput('has_error', 'false');
            } catch (error) {
              console.log(`Error checking CodeRabbit status: ${error.message}`);
              core.setOutput('is_completed', 'false');
              core.setOutput('has_error', 'true');
            }

      - name: Check for Critical/Major issues from CodeRabbit
        if: |
          steps.check_coderabbit_status.outputs.is_completed == 'true' &&
          steps.check_coderabbit_status.outputs.has_error == 'false'
        id: check_issues
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = '${{ steps.validate_pr.outputs.pr_number }}';
            const prSha = '${{ steps.validate_pr.outputs.pr_sha }}';
            
            if (!prNumber) {
              console.log('No PR number found');
              core.setOutput('has_issues', 'false');
              return;
            }

            console.log(`Checking PR #${prNumber} for Critical/Major issues from CodeRabbit...`);

            // CodeRabbit ë´‡ í™•ì¸ í•¨ìˆ˜ (í•œ ë²ˆë§Œ ì •ì˜í•˜ì—¬ ì¬ì‚¬ìš©)
            // ì •í™•í•œ ë´‡ ì´ë¦„ë§Œ ë§¤ì¹­í•˜ì—¬ ë‹¤ë¥¸ ë´‡(codecov, codeclimate ë“±)ê³¼ì˜ ì¶©ëŒ ë°©ì§€
            const isCodeRabbitBot = (login) => {
              // ì‚­ì œëœ ì‚¬ìš©ì(ghost user)ì˜ ê²½ìš° loginì´ nullì¼ ìˆ˜ ìˆìŒ
              if (!login || typeof login !== 'string') {
                return false;
              }
              const normalizedLogin = login.toLowerCase();
              return normalizedLogin === 'coderabbitai' ||
                     normalizedLogin === 'coderabbit[bot]' ||
                     normalizedLogin.startsWith('coderabbit') && normalizedLogin.endsWith('[bot]');
            };

            // Critical ë˜ëŠ” Major íŒ¨í„´ ì •ì˜
            const criticalPatterns = [
              /Potential issue \| Critical/i,
              /Potential issue \| Major/i,
              /ğŸ”´.*Critical/i,
              /Critical.*issue/i,
              /Major.*issue/i,
            ];

            let hasCriticalOrMajor = false;

            // 1. PR ë ˆë²¨ ì½”ë©˜íŠ¸ ì²´í¬
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
            });
            
            const codeRabbitComments = comments.filter(
              comment => comment.user?.login && isCodeRabbitBot(comment.user.login)
            );

            console.log(`Found ${codeRabbitComments.length} CodeRabbit PR-level comments`);

            for (const comment of codeRabbitComments) {
              const body = comment.body || '';
              if (criticalPatterns.some(pattern => pattern.test(body))) {
                hasCriticalOrMajor = true;
                console.log(`âŒ Critical or Major issue found in PR comment #${comment.id} by ${comment.user?.login || 'deleted user'}`);
                console.log(`Preview: ${body.substring(0, 150)}...`);
                break;
              }
            }

            // 2. PR ë¦¬ë·° ë°”ë”” ì²´í¬
            if (!hasCriticalOrMajor) {
              try {
                const { data: reviews } = await github.rest.pulls.listReviews({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber,
                });

                for (const review of reviews) {
                  if (review.user?.login && isCodeRabbitBot(review.user.login)) {
                    const body = review.body || '';
                    if (criticalPatterns.some(pattern => pattern.test(body))) {
                      hasCriticalOrMajor = true;
                      console.log(`âŒ Critical or Major issue found in review #${review.id}`);
                      break;
                    }
                  }
                }
              } catch (error) {
                console.log('Could not fetch reviews:', error.message);
              }
            }

            // 3. ì¸ë¼ì¸ ì½”ë“œ ì½”ë©˜íŠ¸ ì²´í¬ (CodeRabbitì´ Critical/Major ì´ìŠˆë¥¼ ì¸ë¼ì¸ ì½”ë©˜íŠ¸ë¡œ ë³´ê³ í•˜ëŠ” ê²½ìš°ê°€ ë§ìŒ)
            if (!hasCriticalOrMajor) {
              try {
                const { data: reviewComments } = await github.rest.pulls.listReviewComments({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber,
                });

                console.log(`Found ${reviewComments.length} review comments, checking for CodeRabbit inline comments...`);

                for (const comment of reviewComments) {
                  if (comment.user?.login && isCodeRabbitBot(comment.user.login)) {
                    const body = comment.body || '';
                    if (criticalPatterns.some(pattern => pattern.test(body))) {
                      // í•´ê²°ë˜ì§€ ì•Šì€ ì½”ë©˜íŠ¸ë§Œ ì°¨ë‹¨ (resolved_atì´ nullì´ë©´ ì•„ì§ í•´ê²°ë˜ì§€ ì•ŠìŒ)
                      if (!comment.resolved_at) {
                        hasCriticalOrMajor = true;
                        console.log(`âŒ Critical or Major issue found in inline comment #${comment.id} (unresolved)`);
                        console.log(`Preview: ${body.substring(0, 150)}...`);
                        break;
                      } else {
                        console.log(`â„¹ï¸ Critical or Major issue found in inline comment #${comment.id} but already resolved`);
                      }
                    }
                  }
                }
              } catch (error) {
                console.log('Could not fetch review comments:', error.message);
              }
            }

            // Status Check ê²°ê³¼ë„ í™•ì¸
            try {
              const { data: checks } = await github.rest.checks.listForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: prSha,
              });

              // CodeRabbit ì²´í¬ê°€ ì‹¤íŒ¨í–ˆëŠ”ì§€ í™•ì¸
              const codeRabbitCheck = checks.check_runs.find(
                check => check.name.includes('CodeRabbit') || check.name.includes('code-rabbit')
              );

              if (codeRabbitCheck && codeRabbitCheck.conclusion === 'failure') {
                hasCriticalOrMajor = true;
                console.log('âŒ CodeRabbit check failed');
              }
            } catch (error) {
              console.log('Could not fetch checks:', error.message);
            }

            // ê²°ê³¼ ì¶œë ¥
            core.setOutput('has_issues', hasCriticalOrMajor.toString());
            
            if (hasCriticalOrMajor) {
              console.log('ğŸš« PR has Critical or Major issues - merge blocked');
            } else {
              console.log('âœ… No Critical or Major issues found - merge allowed');
            }

      - name: Auto merge if no Critical/Major issues
        if: |
          steps.check_coderabbit_status.outputs.is_completed == 'true' &&
          steps.check_coderabbit_status.outputs.has_error == 'false' &&
          steps.check_issues.outputs.has_issues == 'false'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = '${{ steps.validate_pr.outputs.pr_number }}';
            
            if (!prNumber) {
              console.log('No PR number found, skipping merge');
              return;
            }

            // PR ì •ë³´ ê°€ì ¸ì˜¤ê¸°
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
            });

            // ì´ë¯¸ ë¨¸ì§€ë˜ì—ˆê±°ë‚˜ ë‹«í˜”ìœ¼ë©´ ìŠ¤í‚µ
            if (pr.state !== 'open' || pr.merged) {
              console.log(`PR #${prNumber} is not open or already merged`);
              return;
            }

            // ìë™ ë¨¸ì§€ ì‹¤í–‰ (rebase ë°©ì‹)
            try {
              await github.rest.pulls.merge({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
                merge_method: 'rebase',
                commit_title: `Merge PR #${prNumber}: ${pr.title}`,
              });
              
              console.log(`âœ… PR #${prNumber} merged automatically using rebase`);
            } catch (error) {
              // ë¨¸ì§€ ì‹¤íŒ¨ ì‹œ (ì˜ˆ: ì¶©ëŒ, ë¸Œëœì¹˜ ë³´í˜¸ ê·œì¹™ ë“±)
              console.log(`âš ï¸ Could not merge PR #${prNumber}:`, error.message);
              // ì‹¤íŒ¨í•´ë„ ì›Œí¬í”Œë¡œìš°ëŠ” ì„±ê³µìœ¼ë¡œ ì²˜ë¦¬ (ìˆ˜ë™ ë¨¸ì§€ ê°€ëŠ¥)
            }

      - name: Skip message if CodeRabbit not completed
        if: |
          steps.check_coderabbit_status.outputs.is_completed == 'false' ||
          steps.check_coderabbit_status.outputs.has_error == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const hasError = '${{ steps.check_coderabbit_status.outputs.has_error }}' === 'true';
            if (hasError) {
              console.log('âš ï¸ Error checking CodeRabbit status. Skipping auto-merge for safety.');
            } else {
              console.log('â³ CodeRabbit review is still in progress. Waiting for completion...');
              console.log('This workflow will run again when PR is updated after CodeRabbit completes.');
            }

      - name: Comment if Critical/Major issues found
        if: |
          steps.check_coderabbit_status.outputs.is_completed == 'true' &&
          steps.check_coderabbit_status.outputs.has_error == 'false' &&
          steps.check_issues.outputs.has_issues == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = '${{ steps.validate_pr.outputs.pr_number }}';
            
            if (!prNumber) {
              return;
            }

            // ì´ë¯¸ ì½”ë©˜íŠ¸ê°€ ìˆëŠ”ì§€ í™•ì¸ (ì¤‘ë³µ ë°©ì§€)
            const { data: existingComments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
            });

            const hasExistingComment = existingComments.some(
              comment => 
                comment.user?.login === 'github-actions[bot]' &&
                comment.body?.includes('ìë™ ë¨¸ì§€ê°€ ì°¨ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤')
            );

            if (!hasExistingComment) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: 'âš ï¸ **ìë™ ë¨¸ì§€ê°€ ì°¨ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤**\n\nCodeRabbitì´ **Critical** ë˜ëŠ” **Major** ì´ìŠˆë¥¼ ë°œê²¬í–ˆìŠµë‹ˆë‹¤.\n\nì´ìŠˆë¥¼ í•´ê²°í•˜ê±°ë‚˜ "Resolve conversation"ìœ¼ë¡œ í•´ê²° í‘œì‹œë¥¼ í•´ì£¼ì„¸ìš”.\ní•´ê²° í›„ PRì„ ì—…ë°ì´íŠ¸í•˜ë©´ ìë™ìœ¼ë¡œ ë‹¤ì‹œ ì²´í¬ë©ë‹ˆë‹¤.',
              });
            }
