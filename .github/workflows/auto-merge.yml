name: CI/CD

on:
  pull_request:
    types: [opened, synchronize, labeled]
  issue_comment:
    types: [created]
  check_run:
    types: [completed]

jobs:
  check-and-merge:
    runs-on: ubuntu-latest
    # GitHub Actions ê¶Œí•œ ì„¤ì • (PR ì½”ë©˜íŠ¸ ì‘ì„± ë° ë¨¸ì§€ì— í•„ìš”)
    permissions:
      contents: write  # PR ë¨¸ì§€ì— í•„ìš”
      pull-requests: write  # PR ì •ë³´ ì½ê¸° ë° ë¨¸ì§€ì— í•„ìš”
      issues: write  # PR ì½”ë©˜íŠ¸ ì‘ì„±ì— í•„ìš”
      checks: read  # ì²´í¬ ìƒíƒœ í™•ì¸ì— í•„ìš”
    # ê° ì´ë²¤íŠ¸ íƒ€ì…ì— ë”°ë¼ PRì´ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
    # pull_request ì´ë²¤íŠ¸: github.event.pull_request ì¡´ì¬
    # issue_comment ì´ë²¤íŠ¸: github.event.issue.pull_request ì¡´ì¬ (PRì¸ ê²½ìš°)
    # check_run ì´ë²¤íŠ¸: github.event.check_run.pull_requests ë°°ì—´ì´ ì¡´ì¬í•˜ê³  ë¹„ì–´ìˆì§€ ì•ŠìŒ
    # ì°¸ê³ : ì‹¤ì œ PR ê²€ì¦(base.ref, state)ì€ ì²« ë²ˆì§¸ stepì—ì„œ ìˆ˜í–‰ë¨
    # ì°¸ê³ : GitHub Actions í‘œí˜„ì‹ì—ì„œëŠ” ë°°ì—´ ê¸¸ì´ë¥¼ ì§ì ‘ í™•ì¸í•  ìˆ˜ ì—†ìœ¼ë¯€ë¡œ,
    #       check_runì˜ ê²½ìš° pull_requests ë°°ì—´ ì¡´ì¬ë§Œ í™•ì¸í•˜ê³ , ì²« ë²ˆì§¸ stepì—ì„œ ë¹ˆ ë°°ì—´ ì²´í¬ ìˆ˜í–‰
    if: |
      (github.event_name == 'pull_request' && github.event.pull_request != null) ||
      (github.event_name == 'issue_comment' && github.event.issue != null && github.event.issue.pull_request != null) ||
      (github.event_name == 'check_run' && github.event.check_run != null && github.event.check_run.pull_requests != null)
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Get PR information and validate
        id: validate_pr
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            let prNumber = null;
            let pr = null;

            // ì´ë²¤íŠ¸ íƒ€ì…ì— ë”°ë¼ PR ë²ˆí˜¸ ê°€ì ¸ì˜¤ê¸°
            if (context.eventName === 'pull_request') {
              prNumber = context.payload.pull_request?.number;
              pr = context.payload.pull_request;
            } else if (context.eventName === 'issue_comment') {
              prNumber = context.payload.issue?.number;
              // issueê°€ PRì¸ì§€ í™•ì¸í•˜ê³  PR ì •ë³´ ê°€ì ¸ì˜¤ê¸°
              if (context.payload.issue?.pull_request) {
                const { data: prData } = await github.rest.pulls.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber,
                });
                pr = prData;
              }
            } else if (context.eventName === 'check_run') {
              // check_runì˜ ê²½ìš° ì²« ë²ˆì§¸ PR ì‚¬ìš©
              const pullRequests = context.payload.check_run?.pull_requests || [];
              if (pullRequests.length > 0) {
                prNumber = pullRequests[0].number;
                const { data: prData } = await github.rest.pulls.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber,
                });
                pr = prData;
              }
            }

            if (!prNumber || !pr) {
              console.log('No PR found or PR is not accessible');
              core.setOutput('is_valid', 'false');
              return;
            }

            // develop ë˜ëŠ” main ë¸Œëœì¹˜ë¡œì˜ PRì¸ì§€ í™•ì¸
            const baseRef = pr.base?.ref;
            const isValidBase = baseRef === 'develop' || baseRef === 'main';
            
            // PRì´ ì—´ë ¤ìˆëŠ”ì§€ í™•ì¸
            const isOpen = pr.state === 'open' && !pr.merged;

            const isValid = isValidBase && isOpen;

            console.log(`PR #${prNumber}: base=${baseRef}, state=${pr.state}, merged=${pr.merged}, isValid=${isValid}`);

            core.setOutput('is_valid', isValid.toString());
            core.setOutput('pr_number', prNumber.toString());
            core.setOutput('pr_sha', pr.head?.sha || context.sha);

            if (!isValid) {
              if (!isValidBase) {
                console.log(`Skipping: PR targets ${baseRef}, not develop or main`);
              } else if (!isOpen) {
                console.log(`Skipping: PR is ${pr.state}${pr.merged ? ' and merged' : ''}`);
              }
            }

      - name: Check if CodeRabbit review is completed
        if: steps.validate_pr.outputs.is_valid == 'true'
        id: check_coderabbit_status
        continue-on-error: true
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = '${{ steps.validate_pr.outputs.pr_number }}';
            const prSha = '${{ steps.validate_pr.outputs.pr_sha }}';
            
            // í•­ìƒ ê¸°ë³¸ê°’ ì„¤ì • (ìŠ¤í…ì´ ì‹¤íŒ¨í•´ë„ ì¶œë ¥ê°’ì´ ì„¤ì •ë˜ë„ë¡)
            let isCompleted = false;
            
            try {
              if (!prNumber) {
                console.log('No PR number found');
                core.setOutput('is_completed', 'false');
                core.setOutput('has_error', 'true');
                return;
              }

              console.log(`Checking CodeRabbit status for PR #${prNumber}...`);

              // CodeRabbit ì²´í¬ ìƒíƒœ í™•ì¸
              const { data: checks } = await github.rest.checks.listForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: prSha,
              });

              // ë””ë²„ê¹…: ëª¨ë“  ì²´í¬ ì´ë¦„ ì¶œë ¥
              console.log(`Found ${checks.check_runs.length} checks:`);
              checks.check_runs.forEach(check => {
                console.log(`  - ${check.name} (status: ${check.status}, conclusion: ${check.conclusion || 'none'})`);
              });

              // CodeRabbit ì²´í¬ ì°¾ê¸° (ë” ë„“ì€ íŒ¨í„´)
              const codeRabbitCheck = checks.check_runs.find(
                check => {
                  const name = check.name.toLowerCase();
                  return name.includes('coderabbit') || 
                         name.includes('code-rabbit') ||
                         name.includes('code rabbit') ||
                         name === 'code rabbit' ||
                         check.app?.name?.toLowerCase().includes('coderabbit');
                }
              );

              if (!codeRabbitCheck) {
                console.log('CodeRabbit check not found in status checks. Checking reviews...');
                
                // Status Checkê°€ ì—†ìœ¼ë©´ Review ìƒíƒœ í™•ì¸
                try {
                  const reviews = await github.paginate(github.rest.pulls.listReviews, {
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: prNumber,
                  });

                  const codeRabbitReview = reviews.find(
                    review => {
                      const login = review.user?.login?.toLowerCase() || '';
                      const isCodeRabbit = login.includes('coderabbit') || login === 'coderabbitai';
                      const commitMatches = review.commit_id === prSha;
                      const isApproved = review.state === 'APPROVED' || review.state === 'completed';
                      return isCodeRabbit && commitMatches && isApproved;
                    }
                  );

                  if (codeRabbitReview) {
                    // í˜„ì¬ ì»¤ë°‹ì— ëŒ€í•œ ìŠ¹ì¸ëœ CodeRabbit ë¦¬ë·°ê°€ ìˆìœ¼ë©´ ì™„ë£Œëœ ê²ƒìœ¼ë¡œ ê°„ì£¼
                    isCompleted = true;
                    console.log(`CodeRabbit review found for commit ${prSha}: ${codeRabbitReview.state}`);
                  } else {
                    console.log(`CodeRabbit review not found for current commit ${prSha} - may not have started yet or not approved`);
                    core.setOutput('is_completed', 'false');
                    core.setOutput('has_error', 'false');
                    return;
                  }
                } catch (error) {
                  console.log(`Error checking reviews: ${error.message}`);
                  core.setOutput('is_completed', 'false');
                  core.setOutput('has_error', 'false');
                  return;
                }
              } else {
                isCompleted = codeRabbitCheck.status === 'completed';
                console.log(`CodeRabbit check found: ${codeRabbitCheck.name}`);
                console.log(`Status: ${codeRabbitCheck.status}, Conclusion: ${codeRabbitCheck.conclusion || 'none'}, Completed: ${isCompleted}`);
              }
              
              core.setOutput('is_completed', isCompleted.toString());
              core.setOutput('has_error', 'false');
            } catch (error) {
              console.log(`Error checking CodeRabbit status: ${error.message}`);
              core.setOutput('is_completed', 'false');
              core.setOutput('has_error', 'true');
            }

      - name: Check for Critical/Major issues from CodeRabbit
        if: |
          steps.check_coderabbit_status.outputs.is_completed == 'true' &&
          steps.check_coderabbit_status.outputs.has_error == 'false'
        id: check_issues
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = '${{ steps.validate_pr.outputs.pr_number }}';
            const prSha = '${{ steps.validate_pr.outputs.pr_sha }}';
            
            if (!prNumber) {
              console.log('No PR number found');
              core.setOutput('has_issues', 'false');
              return;
            }

            console.log(`Checking PR #${prNumber} for Critical/Major issues from CodeRabbit...`);

            // CodeRabbit ë´‡ í™•ì¸ í•¨ìˆ˜ (í•œ ë²ˆë§Œ ì •ì˜í•˜ì—¬ ì¬ì‚¬ìš©)
            // ì •í™•í•œ ë´‡ ì´ë¦„ë§Œ ë§¤ì¹­í•˜ì—¬ ë‹¤ë¥¸ ë´‡(codecov, codeclimate ë“±)ê³¼ì˜ ì¶©ëŒ ë°©ì§€
            const isCodeRabbitBot = (login) => {
              // ì‚­ì œëœ ì‚¬ìš©ì(ghost user)ì˜ ê²½ìš° loginì´ nullì¼ ìˆ˜ ìˆìŒ
              if (!login || typeof login !== 'string') {
                return false;
              }
              const normalizedLogin = login.toLowerCase();
              return normalizedLogin === 'coderabbitai' ||
                     normalizedLogin === 'coderabbit[bot]' ||
                     normalizedLogin.startsWith('coderabbit') && normalizedLogin.endsWith('[bot]');
            };

            // Critical ë˜ëŠ” Major íŒ¨í„´ ì •ì˜
            const criticalPatterns = [
              /Potential issue \| Critical/i,
              /Potential issue \| Major/i,
              /ğŸ”´.*Critical/i,
              /Critical.*issue/i,
              /Major.*issue/i,
            ];

            let hasCriticalOrMajor = false;

            // 1. PR ë ˆë²¨ ì½”ë©˜íŠ¸ ì²´í¬ (ëª¨ë“  í˜ì´ì§€ ê°€ì ¸ì˜¤ê¸°)
            try {
              const comments = await github.paginate(github.rest.issues.listComments, {
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
              });
              
              const codeRabbitComments = comments.filter(
                comment => comment.user?.login && isCodeRabbitBot(comment.user.login)
              );

              console.log(`Found ${codeRabbitComments.length} CodeRabbit PR-level comments (across all pages)`);

              for (const comment of codeRabbitComments) {
                const body = comment.body || '';
                if (criticalPatterns.some(pattern => pattern.test(body))) {
                  hasCriticalOrMajor = true;
                  console.log(`âŒ Critical or Major issue found in PR comment #${comment.id} by ${comment.user?.login || 'deleted user'}`);
                  console.log(`Preview: ${body.substring(0, 150)}...`);
                  break;
                }
              }
            } catch (error) {
              console.log('Could not fetch PR-level comments:', error.message);
            }

            // 2. PR ë¦¬ë·° ë°”ë”” ì²´í¬ (ëª¨ë“  í˜ì´ì§€ ê°€ì ¸ì˜¤ê¸°)
            if (!hasCriticalOrMajor) {
              try {
                const reviews = await github.paginate(github.rest.pulls.listReviews, {
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber,
                });

                console.log(`Found ${reviews.length} reviews (across all pages), checking for CodeRabbit reviews...`);

                for (const review of reviews) {
                  if (review.user?.login && isCodeRabbitBot(review.user.login)) {
                    const body = review.body || '';
                    if (criticalPatterns.some(pattern => pattern.test(body))) {
                      hasCriticalOrMajor = true;
                      console.log(`âŒ Critical or Major issue found in review #${review.id}`);
                      break;
                    }
                  }
                }
              } catch (error) {
                console.log('Could not fetch reviews:', error.message);
              }
            }

            // 3. ì¸ë¼ì¸ ì½”ë“œ ì½”ë©˜íŠ¸ ì²´í¬ (ëª¨ë“  í˜ì´ì§€ ê°€ì ¸ì˜¤ê¸°)
            // CodeRabbitì´ Critical/Major ì´ìŠˆë¥¼ ì¸ë¼ì¸ ì½”ë©˜íŠ¸ë¡œ ë³´ê³ í•˜ëŠ” ê²½ìš°ê°€ ë§ìŒ
            if (!hasCriticalOrMajor) {
              try {
                const reviewComments = await github.paginate(github.rest.pulls.listReviewComments, {
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber,
                });

                console.log(`Found ${reviewComments.length} review comments (across all pages), checking for CodeRabbit inline comments...`);

                for (const comment of reviewComments) {
                  if (comment.user?.login && isCodeRabbitBot(comment.user.login)) {
                    const body = comment.body || '';
                    if (criticalPatterns.some(pattern => pattern.test(body))) {
                      // í•´ê²°ë˜ì§€ ì•Šì€ ì½”ë©˜íŠ¸ë§Œ ì°¨ë‹¨ (resolved_atì´ nullì´ë©´ ì•„ì§ í•´ê²°ë˜ì§€ ì•ŠìŒ)
                      if (!comment.resolved_at) {
                        hasCriticalOrMajor = true;
                        console.log(`âŒ Critical or Major issue found in inline comment #${comment.id} (unresolved)`);
                        console.log(`Preview: ${body.substring(0, 150)}...`);
                        break;
                      } else {
                        console.log(`â„¹ï¸ Critical or Major issue found in inline comment #${comment.id} but already resolved`);
                      }
                    }
                  }
                }
              } catch (error) {
                console.log('Could not fetch review comments:', error.message);
              }
            }

            // Status Check ê²°ê³¼ë„ í™•ì¸
            try {
              const { data: checks } = await github.rest.checks.listForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: prSha,
              });

              // CodeRabbit ì²´í¬ê°€ ì‹¤íŒ¨í–ˆëŠ”ì§€ í™•ì¸
              const codeRabbitCheck = checks.check_runs.find(
                check => check.name.includes('CodeRabbit') || check.name.includes('code-rabbit')
              );

              if (codeRabbitCheck && codeRabbitCheck.conclusion === 'failure') {
                hasCriticalOrMajor = true;
                console.log('âŒ CodeRabbit check failed');
              }
            } catch (error) {
              console.log('Could not fetch checks:', error.message);
            }

            // ê²°ê³¼ ì¶œë ¥
            core.setOutput('has_issues', hasCriticalOrMajor.toString());
            
            if (hasCriticalOrMajor) {
              console.log('ğŸš« PR has Critical or Major issues - merge blocked');
            } else {
              console.log('âœ… No Critical or Major issues found - merge allowed');
            }

      - name: Auto merge if no Critical/Major issues
        if: |
          steps.check_coderabbit_status.outputs.is_completed == 'true' &&
          steps.check_coderabbit_status.outputs.has_error == 'false' &&
          steps.check_issues.outputs.has_issues == 'false'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = '${{ steps.validate_pr.outputs.pr_number }}';
            
            if (!prNumber) {
              console.log('No PR number found, skipping merge');
              return;
            }

            // PR ì •ë³´ ê°€ì ¸ì˜¤ê¸°
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
            });

            // ì´ë¯¸ ë¨¸ì§€ë˜ì—ˆê±°ë‚˜ ë‹«í˜”ìœ¼ë©´ ìŠ¤í‚µ
            if (pr.state !== 'open' || pr.merged) {
              console.log(`PR #${prNumber} is not open or already merged`);
              return;
            }

            // ìë™ ë¨¸ì§€ ì‹¤í–‰ (rebase ë°©ì‹)
            try {
              console.log(`Attempting to merge PR #${prNumber} using rebase...`);
              
              const mergeResult = await github.rest.pulls.merge({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
                merge_method: 'rebase',
                commit_title: `Merge PR #${prNumber}: ${pr.title}`,
              });
              
              if (mergeResult.data.merged) {
                console.log(`âœ… PR #${prNumber} merged successfully using rebase`);
              } else {
                console.log(`âš ï¸ PR #${prNumber} merge request sent but not merged. Status: ${mergeResult.data.message || 'unknown'}`);
              }
            } catch (error) {
              // ë¨¸ì§€ ì‹¤íŒ¨ ì‹œ ìƒì„¸ ì—ëŸ¬ ì •ë³´ ì¶œë ¥
              console.log(`âŒ Could not merge PR #${prNumber}`);
              console.log(`Error message: ${error.message}`);
              console.log(`Error status: ${error.status || 'unknown'}`);
              
              if (error.response) {
                console.log(`Response data: ${JSON.stringify(error.response.data, null, 2)}`);
              }
              
              // ì¼ë°˜ì ì¸ ì‹¤íŒ¨ ì›ì¸ ì•ˆë‚´
              if (error.status === 405) {
                console.log('ğŸ’¡ Hint: This might be due to branch protection rules or merge conflicts.');
              } else if (error.status === 409) {
                console.log('ğŸ’¡ Hint: Merge conflict detected. Please resolve conflicts manually.');
              }
              
              // ì‹¤íŒ¨í•´ë„ ì›Œí¬í”Œë¡œìš°ëŠ” ì„±ê³µìœ¼ë¡œ ì²˜ë¦¬ (ìˆ˜ë™ ë¨¸ì§€ ê°€ëŠ¥)
            }

      - name: Fail if CodeRabbit not completed
        if: |
          steps.check_coderabbit_status.outputs.is_completed == 'false' ||
          steps.check_coderabbit_status.outputs.has_error == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const hasError = '${{ steps.check_coderabbit_status.outputs.has_error }}' === 'true';
            const prNumber = '${{ steps.validate_pr.outputs.pr_number }}';
            
            if (hasError) {
              console.log('âš ï¸ Error checking CodeRabbit status. Failing workflow for safety.');
              core.setFailed('Failed to check CodeRabbit status');
            } else {
              console.log('â³ CodeRabbit review is still in progress.');
              console.log('This workflow will run again when CodeRabbit completes (via check_run event).');
              console.log(`Waiting for CodeRabbit to complete for PR #${prNumber}...`);
              
              // CodeRabbitì´ ì™„ë£Œë˜ì§€ ì•Šì•˜ìœ¼ë©´ ì›Œí¬í”Œë¡œìš° ì‹¤íŒ¨ ì²˜ë¦¬
              // ì´ë ‡ê²Œ í•˜ë©´ PRì´ ë¨¸ì§€ë˜ì§€ ì•Šê³ , CodeRabbitì´ ì™„ë£Œë˜ë©´ check_run ì´ë²¤íŠ¸ë¡œ ë‹¤ì‹œ ì‹¤í–‰ë¨
              core.setFailed('CodeRabbit review is still in progress. This workflow will run again automatically when CodeRabbit completes.');
            }

      - name: Comment if Critical/Major issues found
        if: |
          steps.check_coderabbit_status.outputs.is_completed == 'true' &&
          steps.check_coderabbit_status.outputs.has_error == 'false' &&
          steps.check_issues.outputs.has_issues == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = '${{ steps.validate_pr.outputs.pr_number }}';
            
            if (!prNumber) {
              return;
            }

            // ì´ë¯¸ ì½”ë©˜íŠ¸ê°€ ìˆëŠ”ì§€ í™•ì¸ (ì¤‘ë³µ ë°©ì§€)
            const { data: existingComments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
            });

            const hasExistingComment = existingComments.some(
              comment => 
                comment.user?.login === 'github-actions[bot]' &&
                comment.body?.includes('ìë™ ë¨¸ì§€ê°€ ì°¨ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤')
            );

            if (!hasExistingComment) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: 'âš ï¸ **ìë™ ë¨¸ì§€ê°€ ì°¨ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤**\n\nCodeRabbitì´ **Critical** ë˜ëŠ” **Major** ì´ìŠˆë¥¼ ë°œê²¬í–ˆìŠµë‹ˆë‹¤.\n\nì´ìŠˆë¥¼ í•´ê²°í•˜ê±°ë‚˜ "Resolve conversation"ìœ¼ë¡œ í•´ê²° í‘œì‹œë¥¼ í•´ì£¼ì„¸ìš”.\ní•´ê²° í›„ PRì„ ì—…ë°ì´íŠ¸í•˜ë©´ ìë™ìœ¼ë¡œ ë‹¤ì‹œ ì²´í¬ë©ë‹ˆë‹¤.',
              });
            }
