# CI/CD: develop/main PR â†’ CodeRabbit ì™„ë£Œ + Critical/Major ì—†ìŒ â†’ mergeable ëŒ€ê¸° â†’ ìë™ ë¨¸ì§€(rebase)
name: CI/CD

on:
  pull_request:
    types: [opened, synchronize, labeled]
  issue_comment:
    types: [created]
  check_run:
    types: [completed]

jobs:
  check-and-merge:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write
      checks: read
    if: |
      (github.event_name == 'pull_request' && github.event.pull_request != null) ||
      (github.event_name == 'issue_comment' && github.event.issue != null && github.event.issue.pull_request != null) ||
      (github.event_name == 'check_run' && github.event.check_run != null && github.event.check_run.pull_requests != null)
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Get PR and validate (develop/main, open)
        id: validate_pr
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            let prNumber = null, pr = null;
            if (context.eventName === 'pull_request') {
              prNumber = context.payload.pull_request?.number;
              pr = context.payload.pull_request;
            } else if (context.eventName === 'issue_comment' && context.payload.issue?.pull_request) {
              prNumber = context.payload.issue?.number;
              const { data } = await github.rest.pulls.get({ owner: context.repo.owner, repo: context.repo.repo, pull_number: prNumber });
              pr = data;
            } else if (context.eventName === 'check_run') {
              const prs = context.payload.check_run?.pull_requests || [];
              if (prs.length > 0) {
                prNumber = prs[0].number;
                const { data } = await github.rest.pulls.get({ owner: context.repo.owner, repo: context.repo.repo, pull_number: prNumber });
                pr = data;
              }
            }
            if (!prNumber || !pr) {
              core.setOutput('is_valid', 'false');
              return;
            }
            const baseRef = pr.base?.ref;
            const isValid = (baseRef === 'develop' || baseRef === 'main') && pr.state === 'open' && !pr.merged;
            console.log(`PR #${prNumber} base=${baseRef} state=${pr.state} isValid=${isValid}`);
            core.setOutput('is_valid', isValid.toString());
            core.setOutput('pr_number', prNumber.toString());
            core.setOutput('pr_sha', pr.head?.sha || context.sha);
            core.setOutput('pr_head_ref', pr.head?.ref || '');

      - name: Wait for CodeRabbit review completed
        if: steps.validate_pr.outputs.is_valid == 'true'
        id: check_coderabbit_status
        continue-on-error: true
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = '${{ steps.validate_pr.outputs.pr_number }}';
            const prSha = '${{ steps.validate_pr.outputs.pr_sha }}';
            const prHeadRef = '${{ steps.validate_pr.outputs.pr_head_ref }}';
            const POLL_MS = 15000, POLL_MAX = 15 * 60 * 1000 / POLL_MS;
            const sleep = (ms) => new Promise(r => setTimeout(r, ms));
            const isCodeRabbit = (c) => {
              const n = (c.name || '').toLowerCase(), a = (c.app?.name || '').toLowerCase();
              return n.includes('coderabbit') || n.includes('code-rabbit') || n.includes('code rabbit') || a.includes('coderabbit');
            };
            const fetchRuns = (ref) => github.paginate(github.rest.checks.listForRef,
              { owner: context.repo.owner, repo: context.repo.repo, ref, per_page: 100, filter: 'all' },
              (res) => res.data.check_runs || []);
            async function runCheck(attempt) {
              const bySha = await fetchRuns(prSha);
              let byBranch = [];
              if (prHeadRef) {
                const refs = prHeadRef.startsWith('heads/') ? [prHeadRef] : [prHeadRef, 'heads/' + prHeadRef];
                for (const ref of refs) {
                  try { byBranch = await fetchRuns(ref); if (byBranch.length) break; } catch (e) {}
                }
              }
              const seen = new Set();
              const all = [...bySha, ...byBranch].filter(r => r.id && !seen.has(r.id) && (seen.add(r.id), true));
              if (attempt === 0) console.log('Check runs:', all.map(c => `${c.name}=${c.status}/${c.conclusion || '-'}`).join(', ') || '(none)');
              const cr = all.find(isCodeRabbit);
              if (cr) {
                if (cr.status !== 'completed') return { ok: false, err: false };
                if (cr.conclusion === 'success') return { ok: true, err: false };
                return { ok: false, err: true };
              }
              const reviews = await github.paginate(github.rest.pulls.listReviews,
                { owner: context.repo.owner, repo: context.repo.repo, pull_number: prNumber });
              const rev = reviews.find(r => (r.user?.login || '').toLowerCase().includes('coderabbit') && r.commit_id === prSha
                && ['APPROVED','COMMENTED','completed'].includes(r.state));
              return { ok: !!rev, err: false };
            }
            try {
              for (let i = 0; i <= POLL_MAX; i++) {
                const { ok, err } = await runCheck(i);
                if (err) { core.setOutput('is_completed', 'false'); core.setOutput('has_error', 'true'); return; }
                if (ok) { core.setOutput('is_completed', 'true'); core.setOutput('has_error', 'false'); return; }
                if (i < POLL_MAX) { console.log(`CodeRabbit pending, wait ${POLL_MS/1000}s (${i+1}/${POLL_MAX})`); await sleep(POLL_MS); }
                else { core.setOutput('is_completed', 'false'); core.setOutput('has_error', 'false'); core.setFailed('CodeRabbit did not complete in time.'); }
              }
            } catch (e) {
              console.log('CodeRabbit check error:', e.message);
              core.setOutput('is_completed', 'false'); core.setOutput('has_error', 'true');
            }

      - name: Check CodeRabbit Critical/Major (comments, reviews, inline, check failure)
        if: |
          steps.check_coderabbit_status.outputs.is_completed == 'true' &&
          steps.check_coderabbit_status.outputs.has_error == 'false'
        id: check_issues
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = '${{ steps.validate_pr.outputs.pr_number }}';
            const prSha = '${{ steps.validate_pr.outputs.pr_sha }}';
            const isBot = (login) => {
              if (!login || typeof login !== 'string') return false;
              const L = login.toLowerCase();
              return L === 'coderabbitai' || L === 'coderabbit[bot]' || (L.startsWith('coderabbit') && L.endsWith('[bot]'));
            };
            const CRITICAL = [/Potential issue \| Critical/i, /Potential issue \| Major/i, /ğŸ”´.*Critical/i, /Critical.*issue/i, /Major.*issue/i];
            const hasCritical = (body) => CRITICAL.some(p => p.test(body || ''));
            let block = false;
            const opts = { owner: context.repo.owner, repo: context.repo.repo };
            try {
              const comments = await github.paginate(github.rest.issues.listComments, { ...opts, issue_number: prNumber });
              if (comments.filter(c => c.user?.login && isBot(c.user.login)).some(c => hasCritical(c.body))) block = true;
            } catch (e) {}
            if (!block) try {
              const reviews = await github.paginate(github.rest.pulls.listReviews, { ...opts, pull_number: prNumber });
              if (reviews.filter(r => isBot(r.user?.login)).some(r => hasCritical(r.body))) block = true;
            } catch (e) {}
            if (!block) try {
              const inlines = await github.paginate(github.rest.pulls.listReviewComments, { ...opts, pull_number: prNumber });
              if (inlines.some(c => isBot(c.user?.login) && hasCritical(c.body) && !c.resolved_at)) block = true;
            } catch (e) {}
            if (!block) try {
              const { data } = await github.rest.checks.listForRef({ ...opts, ref: prSha });
              const cr = (data.check_runs || []).find(c => (c.name||'').toLowerCase().includes('coderabbit') || (c.app?.name||'').toLowerCase().includes('coderabbit'));
              if (cr && cr.conclusion === 'failure') block = true;
            } catch (e) {}
            core.setOutput('has_issues', block.toString());
            console.log(block ? 'ğŸš« Critical/Major found - merge blocked' : 'âœ… No Critical/Major - merge allowed');

      - name: Auto merge (wait mergeable, then rebase)
        if: |
          steps.check_coderabbit_status.outputs.is_completed == 'true' &&
          steps.check_coderabbit_status.outputs.has_error == 'false' &&
          steps.check_issues.outputs.has_issues == 'false'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = '${{ steps.validate_pr.outputs.pr_number }}';
            const validatedSha = '${{ steps.validate_pr.outputs.pr_sha }}';
            const opts = { owner: context.repo.owner, repo: context.repo.repo, pull_number: prNumber };
            const sleep = (ms) => new Promise(r => setTimeout(r, ms));
            const POLL_MS = 30000, POLL_MAX = 20; // 10 min
            let pr = (await github.rest.pulls.get(opts)).data;
            if (!prNumber || pr.state !== 'open' || pr.merged) return;
            if (pr.head?.sha && validatedSha && pr.head?.sha !== validatedSha) {
              console.log('PR head changed during wait, skip merge');
              return;
            }
            for (let i = 0; i <= POLL_MAX; i++) {
              pr = (await github.rest.pulls.get(opts)).data;
              if (pr.state !== 'open' || pr.merged) return;
              if (pr.mergeable === true && (pr.mergeable_state === 'clean' || pr.mergeable_state === 'unstable')) {
                console.log('PR mergeable, merging...');
                break;
              }
              if (i === POLL_MAX) {
                console.log('Still not mergeable after 10 min (required checks may be pending). Will retry on check_run.');
                return;
              }
              console.log(`Wait mergeable (${i+1}/${POLL_MAX}) mergeable=${pr.mergeable} state=${pr.mergeable_state}`);
              await sleep(POLL_MS);
            }
            try {
              const res = await github.rest.pulls.merge({ ...opts, merge_method: 'rebase', commit_title: `Merge PR #${prNumber}: ${pr.title}` });
              console.log(res.data.merged ? `âœ… PR #${prNumber} merged` : `âš ï¸ Merge returned: ${res.data.message || 'unknown'}`);
            } catch (e) {
              console.log('Merge failed:', e.message, e.response?.data ? JSON.stringify(e.response.data) : '');
              if (e.status === 405) console.log('Hint: Branch protection or required checks.');
              if (e.status === 409) console.log('Hint: Merge conflict.');
              core.setFailed(`Auto-merge failed: ${e.message}`);
            }

      - name: Fail if CodeRabbit not done or error
        if: |
          steps.check_coderabbit_status.outputs.is_completed == 'false' ||
          steps.check_coderabbit_status.outputs.has_error == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const hasError = '${{ steps.check_coderabbit_status.outputs.has_error }}' === 'true';
            core.setFailed(hasError ? 'Failed to check CodeRabbit status' : 'CodeRabbit review still in progress (will re-run on check_run).');

      - name: Comment when Critical/Major blocks merge
        if: |
          steps.check_coderabbit_status.outputs.is_completed == 'true' &&
          steps.check_coderabbit_status.outputs.has_error == 'false' &&
          steps.check_issues.outputs.has_issues == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = '${{ steps.validate_pr.outputs.pr_number }}';
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner, repo: context.repo.repo, issue_number: prNumber
            });
            const already = comments.some(c => c.user?.login === 'github-actions[bot]' && c.body?.includes('ìë™ ë¨¸ì§€ê°€ ì°¨ë‹¨'));
            if (!already) await github.rest.issues.createComment({
              owner: context.repo.owner, repo: context.repo.repo, issue_number: prNumber,
              body: 'âš ï¸ **ìë™ ë¨¸ì§€ê°€ ì°¨ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤**\n\nCodeRabbitì´ **Critical** ë˜ëŠ” **Major** ì´ìŠˆë¥¼ ë°œê²¬í–ˆìŠµë‹ˆë‹¤.\n\nì´ìŠˆë¥¼ í•´ê²°í•˜ê±°ë‚˜ "Resolve conversation"ìœ¼ë¡œ í•´ê²° í‘œì‹œë¥¼ í•´ì£¼ì„¸ìš”.\ní•´ê²° í›„ PRì„ ì—…ë°ì´íŠ¸í•˜ë©´ ìë™ìœ¼ë¡œ ë‹¤ì‹œ ì²´í¬ë©ë‹ˆë‹¤.'
            });
